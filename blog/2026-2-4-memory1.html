<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <title>Classical memory in quantum mechanics – Francesco Caravelli</title>
  <link rel="stylesheet" href="../assets/css/style.css" />
  <link href="https://fonts.googleapis.com/css2?family=Merriweather:wght@400;700&family=Inter:wght@300;500;700&display=swap" rel="stylesheet">

  <style>
    p.math { margin: 1rem 0; }
    img.hero { max-width: 100%; height: auto; border-radius: 12px; }
    .note { font-size: 0.95rem; opacity: 0.9; }
    .hr { height: 1px; background: rgba(0,0,0,0.12); margin: 1.25rem 0; }
  </style>

  <!-- AdSense: load ONCE per page -->
  <script async
    src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6719988103594554"
    crossorigin="anonymous"></script>

  <!-- KaTeX -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js"></script>

  <script defer>
    function renderKatexIn(el) {
      if (!el || typeof renderMathInElement !== "function") return;
      renderMathInElement(el, {
        delimiters: [
          { left: "$$", right: "$$", display: true },
          { left: "\\[", right: "\\]", display: true },
          { left: "$", right: "$", display: false },
          { left: "\\(", right: "\\)", display: false }
        ],
        throwOnError: false,
        macros: { "\\mathbbm": "\\mathbb" },
        ignoredTags: ["script", "noscript", "style", "textarea", "pre", "code"]
      });
    }

    document.addEventListener("DOMContentLoaded", () => {
      renderKatexIn(document.querySelector("main.content"));
    });
  </script>
</head>

<body>
  <div class="layout">
    <!-- Sidebar -->
    <div id="sidebar"></div>

    <main class="content">

      <!-- In-article AdSense Ad -->
      <ins class="adsbygoogle"
           style="display:block"
           data-ad-format="fluid"
           data-ad-layout-key="-ef+6k-30-ac+ty"
           data-ad-client="ca-pub-6719988103594554"
           data-ad-slot="9710109684"></ins>
      <script>
        (adsbygoogle = window.adsbygoogle || []).push({});
      </script>

<section id="classical-memory-qm">

  <h3>Classical memory in quantum mechanics</h3>
  <p><em>February 4, 2026</em></p>

  <img class="hero" src="images/classical-memory-qm.png" alt="Classical memory in quantum mechanics hero image">

  <p>
    This post is based on my recent preprint
    <a href="https://arxiv.org/abs/2601.20287">Fingerprints of classical memory in quantum hysteresis</a>.
    This paper was inspired by recent results on annealer machines lead by Nisoli and collaborators, but during the literature review I discovered
    various papers by David Cory that had the filtered Hamiltonian picture I described.
    It is different however in the sense that the paper's pitch is quite different, as I focus on hysteresis: you can get memory-like hysteresis in a <em>perfectly unitary</em> quantum system
    if the control field that reaches the chip is not the waveform you think you sent. It leads to a set of coupled ODEs that is structurally identical to memristive circuits, 
    except that one has unitary dynamics replacing the Ohm's law. In the paper I had two derivations of the filtered Hamiltonian picture: one phenomenological, and one from first 
    principles using Kubo linear response. I think both are useful, so I reproduce them here. And in addition, I had not seen the Kubo version presented in this way before.
  </p>

  <p class="note">
    Note: I apologize in advance.. in what follows, I’ll be annoyingly explicit about what is classical and what is quantum.
    The point is not philosophical, but it is a bookkeeping exercise.
  </p>

  <div class="hr"></div>


  <p>
    Suppose you can control (e.g.  command) a waveform <span class="math">\(u(t)\)</span> at room temperature.
    This what you think your quantum Hamiltonian <span class="math">\(\H(t)\)</span> will receive. Because the physics is not as simple,
    your (otherwise) theoretical device will actually
    see a <em>realized</em> field <span class="math">\(\Phi(t)\)</span> produced by a causal filter, e.g. in practice your cables will induce a sort of delay or memory function 
    <span class="math">K(\tau)</span>, e.g.
  </p>

  <p class="math">
    $$
    \Phi(t) = \Phi_0 + (K*u)(t)
    = \Phi_0 + \int_{-\infty}^{t} K(t-s)\,u(s)\,ds,
    \qquad K(\tau)=0\ \text{for}\ \tau<0.
    $$
  </p>
  Now this should not be surprising.
  <p>
    Now pick an observable <span class="math">\(O(t)=\langle\psi(t)|\hat O|\psi(t)\rangle\)</span> and run a cycle
    <span class="math">\(t\in[0,T]\)</span>. You can draw three parametric loops:
  </p>
  <ul>
    <li><span class="math">\((u,\Phi)\)</span>: the control-channel loop</li>
    <li><span class="math">\((\Phi,O)\)</span>: the device’s loop vs the realized drive</li>
    <li><span class="math">\((u,O)\)</span>: the “what you plot in the lab” loop</li>
  </ul>

  <p>
    A compact way to quantify these loops is by oriented areas (line integrals):
  </p>

  <p class="math">
    $$
    A_{u\Phi}=\oint \Phi\,du,\qquad
    A_{\Phi O}=\oint O\,d\Phi,\qquad
    A_{uO}=\oint O\,du.
    $$
  </p>

  <p>
    Here’s the trap: even if the device has <span class="math">\(A_{\Phi O}=0\)</span> (no hysteresis with respect to the
    realized field), you can still have <span class="math">\(A_{uO}\neq 0\)</span> purely because
    <span class="math">\(u\mapsto \Phi\)</span> has memory.
  </p>

  <p>
    The cleanest cartoon is a pure lag kernel:
  </p>

  <p class="math">
    $$
    K(\tau)=\delta(\tau-t_{\rm lag})
    \quad\Rightarrow\quad
    \Phi(t)=u(t-t_{\rm lag}).
    $$
  </p>

  <p>
    If <span class="math">\(O(t)=f(\Phi(t))\)</span> is single-valued in <span class="math">\(\Phi\)</span>,
    then the loop in <span class="math">\((\Phi,O)\)</span> is not a loop at all, but the curve
    <span class="math">\(O=f(\Phi)\)</span>. Yet the loop in <span class="math">\((u,O)\)</span> generally encloses area
    because <span class="math">\(O(t)=f(u(t-t_{\rm lag}))\)</span>.
  </p>

  <div class="hr"></div>
  
  <p>
    The quantum system itself is still driven by an ordinary Schrödinger equation. A standard model is:
  </p>

  <p class="math">
    $$
    i\frac{d}{dt}\,|\psi(t)\rangle
    =
    \big(\hat H_A+\Phi(t)\,\hat M\big)\,|\psi(t)\rangle,
    \qquad
    \hat U(t)=\mathcal T \exp\!\left(-i\int_0^t \hat H(\tau)\,d\tau\right).
    $$
  </p>

  <p>
    The important point is: once <span class="math">\(\Phi(t)\)</span> is specified, the evolution is unitary
    as long as <span class="math">\(\hat H(t)\)</span> is Hermitian.
    The “memory” lives in the classical map <span class="math">\(u(\cdot)\mapsto \Phi(\cdot)\)</span>, not in
    the state evolution.
  </p>

</section>

<section id="part1-classical-rc">

  <h3>Part 1 — Classical control memory: RC ladders as “memristive-like” state-space filters</h3>

  <p>
    The control stack is often well captured (at the envelope frequencies that matter for pulses) by passive, lossy,
    relaxational dynamics — in other words: RC physics.
    The punchline is that an RC ladder gives you a <em>finite-dimensional dynamical system</em> whose internal states
    store the past. That is exactly the structural role played by internal variables in circuit elements with memory.
  </p>


  <p>
    Consider an <span class="math">\(N\)</span>-stage ladder composed of a series of resistors with capacitors in parallel between the ground and connected between the resistors: the input is <span class="math">\(V_0(t)=u(t)\)</span>,
    node voltages are <span class="math">\(V_j(t)\)</span>, and the device node is
    <span class="math">\(\Phi(t)=V_N(t)\)</span>.
  </p>

  <p class="math">
    $$
    \Phi(t)=V_N(t).
    $$
  </p>

  <p>
    Kirchhoff’s current law at node <span class="math">\(j\)</span> gives a chain of first-order ODEs. For example,
    the interior nodes satisfy
  </p>

  <p class="math">
    $$
    C_j \dot V_j(t)
    =
    \frac{V_{j-1}(t)-V_j(t)}{R_j}
    -
    \frac{V_j(t)-V_{j+1}(t)}{R_{j+1}},
    \qquad j=2,\dots,N-1,
    $$
  </p>

  <p>
    with the appropriate boundary forms at <span class="math">\(j=1\)</span> and <span class="math">\(j=N\)</span>.
    In the uniform case <span class="math">\(R_j\equiv R\)</span>, <span class="math">\(C_j\equiv C\)</span> this reduces to a
    discrete diffusion equation along the line.
  </p>

  <p>
    Collecting <span class="math">\(\vec V(t)=(V_1(t),\dots,V_N(t))^T\)</span>, the ladder is a linear time-invariant
    state-space system:
  </p>

  <p class="math">
    $$
    \dot{\vec V}(t)=A\,\vec V(t)+\vec b\,u(t),
    \qquad
    \Phi(t)=\vec e_N^{\,T}\vec V(t).
    $$
  </p>

  <div class="hr"></div>

  <p>
    Any finite ladder has a rational transfer function
    <span class="math">\(G(s)=\Phi(s)/u(s)\)</span>, and passivity puts the poles on the negative real axis.
    The natural consequence is a sum of relaxational modes:
  </p>

  <p class="math">
    $$
    G(s)=g_\infty+\sum_{k=1}^{K}\frac{c_k}{s+\nu_k},
    \qquad \nu_k>0,
    $$
  </p>

  <p class="math">
    $$
    K(\tau)=g_\infty\,\delta(\tau)+\sum_{k=1}^{K}c_k e^{-\nu_k\tau}\,\Theta(\tau).
    $$
  </p>

  <p>
    This is the place where the “memory kernel” stops being mystical and becomes circuit theory:
    a hierarchy of decay rates <span class="math">\(\{\nu_k\}\)</span> is literally the ladder’s internal relaxation spectrum.
  </p>

  <div class="hr"></div>

  <p>
    To understand where memory is coming from, introduce the auxiliary “filter modes”
  </p>

  <p class="math">
    $$
    \Phi_k(t):=\int_{-\infty}^t c_k\,e^{-\nu_k(t-s)}u(s)\,ds,
    \qquad
    \Phi(t)=g_\infty u(t)+\sum_{k=1}^{K}\Phi_k(t).
    $$
  </p>

  <p>
    Then each mode obeys a simple first-order decay+drive ODE:
  </p>

  <p class="math">
    $$
    \dot \Phi_k(t)=-\nu_k \Phi_k(t)+c_k u(t),
    \qquad k=1,\dots,K.
    $$
  </p>

  <p>
    Pair that with the Schrödinger equation:
  </p>

  <p class="math">
    $$
    i\frac{d}{dt}|\psi(t)\rangle
    =
    \left(\hat H_A+\Big[g_\infty u(t)+\sum_{k=1}^K \Phi_k(t)\Big]\hat M\right)|\psi(t)\rangle.
    $$
  </p>

  <p class="note">
    This is the structural analogy to “memristive / memory circuit” descriptions: a set of internal classical state
    variables <span class="math">\(\{\Phi_k\}\)</span> stores history and feeds back into the input–output map,
    while the controlled system (here: quantum) evolves under a time-local equation once those states are included.
  </p>

  <p>
    The minimal example is the single-RC element:
  </p>

  <p class="math">
    $$
    \tau_c \dot \Phi(t)+\Phi(t)=u(t),
    \qquad \tau_c=RC,
    $$
  </p>

  <p>
    which already produces phase lag, loop area in <span class="math">\((u,\Phi)\)</span>, and therefore “apparent hysteresis”
    in <span class="math">\((u,O)\)</span>.
  </p>

</section>

<section id="part2-kubo">

  <h3>Part 2 — The same structure from quantum mechanics: Kubo + Born–Oppenheimer + tracing out</h3>

  <p>
    Now for the punchline I actually care about: you can derive the same filtered-control structure starting from a
    microscopic quantum model of the control hardware.
    In the paper this is done in Appendix H, and the message is:
    <em>the kernel K(t) that I introduced earlier can be interpreted quantum mechanically as a retarded susceptibility</em>.
  </p>

  <p class="note">
    This section follows closely Appendix H of the paper: start from a microscopic bipartite model, derive an effective
    filtered-control Hamiltonian for the device, and identify the memory kernel as a retarded susceptibility. 
  </p>

  <div class="hr"></div>

  <p>
    Let the total Hilbert space factor as <span class="math">\( \mathcal H = \mathcal H_A \otimes \mathcal H_B \)</span>,
    where <span class="math">\(A\)</span> is the device and <span class="math">\(B\)</span> is the control channel (filters/wiring/etc.).
    We assume the commanded classical waveform <span class="math">\(u(t)\)</span> drives the channel at an input port,
    and the device couples to an output-port field operator. The total Hamiltonian is (setting <span class="math">\(\hbar=1\)</span>):
  </p>

  <p class="math">
    $$
    \hat H(t)
    =
    \hat H_A \otimes \mathbb I_B
    +
    \mathbb I_A \otimes \hat H_B
    +
    g\,\hat M \otimes \hat L
    -
    u(t)\,\mathbb I_A \otimes \hat F .
    $$
  </p>

  <p>
    Here <span class="math">\(\hat F\)</span> is the channel operator conjugate to the applied drive,
    <span class="math">\(\hat L\)</span> is the channel “delivered field” at the device node
    (the paper notes <span class="math">\(\hat L \equiv \hat B\)</span> in other sections),
    <span class="math">\(\hat M\)</span> is the device coupling operator, and <span class="math">\(g\)</span> quantifies loading/backaction. 
  </p>

  <div class="hr"></div>


  <p>
    Assume an initial product state at time <span class="math">\(t_0\)</span>:
  </p>

  <p class="math">
    $$
    \hat\rho(t_0)=\hat\rho_A(t_0)\otimes \hat\rho_B,
    \qquad [\hat\rho_B,\hat H_B]=0.
    $$
  </p>

  <p>
    The exact evolution is unitary:
  </p>

  <p class="math">
    $$
    \hat\rho(t)=\hat U(t,t_0)\,\hat\rho(t_0)\,\hat U^\dagger(t,t_0),
    \qquad
    \hat U(t,t_0)=\mathcal T\exp\!\left(-i\int_{t_0}^{t}\hat H(s)\,ds\right).
    $$
  </p>

  <p>
    The reduced device state is the partial trace:
    <span class="math">\(\hat\rho_A(t):=\mathrm{Tr}_B[\hat\rho(t)]\)</span>. 
  </p>

  <p>
    To be explicit, fix an orthonormal basis <span class="math">\(\{|n\rangle\}\)</span> of <span class="math">\(\mathcal H_B\)</span>.
    Then by definition
  </p>

  <p class="math">
    $$
    \mathrm{Tr}_B[\hat X]
    :=
    \sum_{n}
    \big(\mathbb I_A\otimes\langle n|\big)\,\hat X\,\big(\mathbb I_A\otimes|n\rangle\big),
    \qquad
    \hat X\in\mathcal B(\mathcal H_A\otimes\mathcal H_B).
    $$
  </p>

  <div class="hr"></div>


  <p>
    We now start from the Liouville–von Neumann equation
    <span class="math">\(\dot{\hat\rho}(t)=-i[\hat H(t),\hat\rho(t)]\)</span> and differentiate under the partial trace:
  </p>

  <p class="math">
    $$
    \dot{\hat\rho}_A(t)
    =
    \mathrm{Tr}_B[\dot{\hat\rho}(t)]
    =
    -i\,\mathrm{Tr}_B\!\left([\hat H(t),\hat\rho(t)]\right).
    $$
  </p>

  <p>
    Now we use the standard partial-trace identities (pull-through and cyclicity on subsystem <span class="math">\(B\)</span>):
    
  </p>

  <p class="math">
    $$
    \mathrm{Tr}_B\big[(\hat A\otimes\mathbb I_B)\hat X\big]=\hat A\,\mathrm{Tr}_B[\hat X],
    \qquad
    \mathrm{Tr}_B\big[\hat X(\hat A\otimes\mathbb I_B)\big]=\mathrm{Tr}_B[\hat X]\,\hat A,
    $$
    $$
    \mathrm{Tr}_B\big[(\mathbb I_A\otimes \hat Z)\hat X\big]=\mathrm{Tr}_B\big[\hat X(\mathbb I_A\otimes \hat Z)\big].
    $$
  </p>

  <p>
    Insert the Hamiltonian decomposition and treat terms one by one. 
  </p>

  <h5>(i) The device self-Hamiltonian gives the usual commutator</h5>

  <p class="math">
    $$
    -i\,\mathrm{Tr}_B\!\left([\hat H_A\otimes\mathbb I_B,\hat\rho]\right)
    =
    -i\,[\hat H_A,\hat\rho_A].
    $$
  </p>

  <h5>(ii) Anything acting only on <span class="math">\(B\)</span> vanishes <em>directly</em> under the trace</h5>

  <p>
    Using cyclicity on <span class="math">\(B\)</span>, one has
    <span class="math">\(\mathrm{Tr}_B([\mathbb I_A\otimes \hat Z,\hat\rho])=0\)</span>
    for any <span class="math">\(\hat Z\)</span> on <span class="math">\(B\)</span>. This applies to
    <span class="math">\(\mathbb I_A\otimes \hat H_B\)</span> and also to the classical drive term
    <span class="math">\(-u(t)\mathbb I_A\otimes \hat F\)</span> at this stage: they influence
    <span class="math">\(\dot{\hat\rho}_A\)</span> only indirectly through how they shape the full joint state <span class="math">\(\hat\rho(t)\)</span>. 
  </p>

  <h5>(iii) The coupling term produces an operator-valued “field”</h5>

  <p>
    Consider <span class="math">\(\mathrm{Tr}_B([\hat M\otimes \hat L,\hat\rho])\)</span>.
    Writing the commutator explicitly and using pull-through/cyclicity as in the appendix, you obtain the exact identity: 
  </p>

  <p class="math">
    $$
    \mathrm{Tr}_B\!\left([\hat M\otimes \hat L,\hat\rho]\right)
    =
    \left[\hat M,\ \mathrm{Tr}_B\!\big((\mathbb I_A\otimes \hat L)\hat\rho\big)\right].
    $$
  </p>

  <p>
    Define the operator-valued field on the device Hilbert space:
  </p>

  <p class="math">
    $$
    \hat X_L(t)
    :=
    \mathrm{Tr}_B\!\big((\mathbb I_A\otimes \hat L)\hat\rho(t)\big)
    \in \mathcal B(\mathcal H_A).
    $$
  </p>

  <p>
    Putting (i)–(iii) together gives the <em>exact</em> reduced equation:
    
  </p>

  <p class="math">
    $$
    \dot{\hat\rho}_A(t)
    =
    -i[\hat H_A,\hat\rho_A(t)]
    -ig\,[\hat M,\hat X_L(t)].
    $$
  </p>

  <p class="note">
    Up to here, nothing has been approximated: all the complexity is buried in <span class="math">\(\hat X_L(t)\)</span>,
    which depends on the full correlated state <span class="math">\(\hat\rho(t)\)</span>. 
  </p>

  <div class="hr"></div>

  <p>
    Now impose the weak-loading  (or Born–Oppenheimer in the Breuer-Petruccione) assumption: there is a regime where the device perturbs the channel only weakly,
    so to leading order the joint state factorizes as
    
  </p>

  <p class="math">
    $$
    \hat\rho(t)
    =
    \hat\rho_A(t)\otimes \hat\rho_B^{(u)}(t) + \mathcal O(g),
    $$
  </p>

  <p>
    where <span class="math">\(\hat\rho_B^{(u)}(t)\)</span> is the channel state produced by the drive in the absence of the device,
    i.e. evolved under the driven channel Hamiltonian
    
  </p>

  <p class="math">
    $$
    \hat H_B^{(u)}(t)=\hat H_B - u(t)\hat F.
    $$
  </p>

  <p>
    Under this factorization,
    
  </p>

  <p class="math">
    $$
    \hat X_L(t)
    =
    \mathrm{Tr}_B\!\big((\mathbb I_A\otimes \hat L)\,\hat\rho_A\otimes \hat\rho_B^{(u)}\big)
    +\mathcal O(g)
    =
    \hat\rho_A(t)\,\Phi(t)+\mathcal O(g),
    $$
  </p>

  <p class="math">
    $$
    \Phi(t) := \mathrm{Tr}_B\!\left(\hat\rho_B^{(u)}(t)\hat L\right).
    $$
  </p>

  <p>
    Plugging back into the exact reduced equation gives, to leading order in <span class="math">\(g\)</span>,
    a purely Hamiltonian (unitary) evolution for the device with a <em>c-number</em> realized field:
    
  </p>

  <p class="math">
    $$
    \dot{\hat\rho}_A(t)
    =
    -i\,[\hat H_A + g\,\Phi(t)\hat M,\ \hat\rho_A(t)]
    +\mathcal O(g^2).
    $$
  </p>

  <p class="note">
    This is the core “filtered Hamiltonian” result: the device remains unitary once <span class="math">\(\Phi(t)\)</span> is specified.
    Any genuine dissipative/Lindblad contribution arises at higher order from channel fluctuations (not needed for the main memory mechanism). 
  </p>

  <div class="hr"></div>

  <p>
    We now derive the convolution form for <span class="math">\(\Phi(t)\)</span>.
    Fix an initial time <span class="math">\(t_0\)</span> where the drive is specified and prepare the channel in a stationary
    reference state for the unforced Hamiltonian:
  </p>

  <p class="math">
    $$
    \hat\rho_B^{(u)}(t_0)=\hat\rho_B,
    \qquad
    [\hat\rho_B,\hat H_B]=0.
    $$
  </p>

  <p>
    Work in the interaction picture with respect to the unforced channel Hamiltonian <span class="math">\(\hat H_B\)</span>:
  </p>

  <p class="math">
    $$
    \hat O_I(t)=e^{i\hat H_B(t-t_0)}\,\hat O\,e^{-i\hat H_B(t-t_0)},
    \qquad
    \hat\rho_I(t)=e^{i\hat H_B(t-t_0)}\,\hat\rho_B^{(u)}(t)\,e^{-i\hat H_B(t-t_0)}.
    $$
  </p>

  <p>
    Since the driven channel Hamiltonian is <span class="math">\(\hat H_B^{(u)}(t)=\hat H_B-u(t)\hat F\)</span>, the interaction-picture
    density operator obeys (this is the standard Kubo starting point):
  </p>

  <p class="math">
    $$
    \frac{d}{dt}\hat\rho_I(t)
    =
    i\,u(t)\,[\hat F_I(t),\hat\rho_I(t)],
    \qquad
    \hat\rho_I(t_0)=\hat\rho_B.
    $$
  </p>

  <h5>First-order (linear response) solution</h5>

  <p>
    Integrate once and iterate (Dyson expansion). To first order in the drive amplitude:
  </p>

  <p class="math">
    $$
    \hat\rho_I(t)
    =
    \hat\rho_B
    +
    i\int_{t_0}^{t} ds\,u(s)\,[\hat F_I(s),\hat\rho_B]
    +\mathcal O(u^2).
    $$
  </p>

  <p>
    The realized field is the channel expectation of <span class="math">\(\hat L\)</span>:
    <span class="math">\(\Phi(t)=\mathrm{Tr}_B(\hat\rho_B^{(u)}(t)\hat L)\)</span>.
    In the interaction picture, this is
    <span class="math">\(\Phi(t)=\mathrm{Tr}_B(\hat\rho_I(t)\hat L_I(t))\)</span>.
  </p>

  <p>
    Plug the first-order expansion of <span class="math">\(\hat\rho_I(t)\)</span> into <span class="math">\(\Phi(t)\)</span>:
  </p>

  <p class="math">
    $$
    \Phi(t)
    =
    \underbrace{\mathrm{Tr}_B(\hat\rho_B\hat L_I(t))}_{\Phi_0}
    +
    i\int_{t_0}^{t} ds\,u(s)\,
    \mathrm{Tr}_B\!\Big([\hat F_I(s),\hat\rho_B]\hat L_I(t)\Big)
    +\mathcal O(u^2).
    $$
  </p>

  <p>
    Use trace cyclicity to rewrite the integrand in commutator form:
    <span class="math">\(\mathrm{Tr}_B([\hat F_I(s),\hat\rho_B]\hat L_I(t))
    =\mathrm{Tr}_B(\hat\rho_B[\hat L_I(t),\hat F_I(s)])\)</span>.
    This yields
  </p>

  <p class="math">
    $$
    \Phi(t)
    =
    \Phi_0
    +
    \int_{t_0}^{t} ds\ \chi_{LF}(t-s)\,u(s)
    +\mathcal O(u^2),
    $$
  </p>

  <p>
    with the retarded susceptibility (causality enforced by the integration domain, equivalently by a Heaviside step):
  </p>

  <p class="math">
    $$
    \chi_{LF}(\tau)
    :=
    i\,\Theta(\tau)\,
    \langle[\hat L_I(\tau),\hat F_I(0)]\rangle_B,
    \qquad
    \langle \cdot \rangle_B := \mathrm{Tr}_B(\hat\rho_B\,\cdot).
    $$
  </p>

  <p>
    Identifying the control kernel as <span class="math">\(K(\tau)\equiv \chi_{LF}(\tau)\)</span>, we get the promised causal filter:
  </p>

  <p class="math">
    $$
    \Phi(t)=\Phi_0+\int_{-\infty}^{t} K(t-s)\,u(s)\,ds
    \qquad
    (K\ \text{retarded}).
    $$
  </p>

  <div class="hr"></div>

  <p>
    Combine now the weak-loading reduction with the Kubo expression for <span class="math">\(\Phi(t)\)</span>.
    To leading order in <span class="math">\(g\)</span> (and linear response in the drive),
    the device evolves unitarily under
    
  </p>

  <p class="math">
    $$
    \dot{\hat\rho}_A(t)
    =
    -i\left[
      \hat H_A + g\,\Phi(t)\hat M,\ \hat\rho_A(t)
    \right]
    +\mathcal O(g^2),
    \qquad
    \Phi(t)=\Phi_0+(K*u)(t).
    $$
  </p>

  <p class="note">
    This is the “classical memory in quantum mechanics” mechanism in one line: the quantum part is unitary once
    <span class="math">\(\Phi(t)\)</span> is given, while the <em>memory</em> enters through the retarded kernel
    <span class="math">\(K(\tau)=\chi_{LF}(\tau)\)</span> of the channel. 
  </p>

</section>


  <div class="hr"></div>

  <h4>5) The "dissipative" Kubo matches the RC story</h4>

  <p>
    If the driven channel’s susceptibility has relaxational poles (lossy, overdamped response),
    then <span class="math">\(\chi_{LF}(t)\)</span> is a sum (or mixture) of decaying exponentials — exactly like an RC ladder’s impulse response.
    That is the bridge between the two “derivations of the same object”:
    circuit theory gives you the kernel by synthesis; Kubo gives you the kernel by response theory.
  </p>

  <p class="note">
    Same math object, two physical viewpoints: (i) passive network modes, (ii) retarded susceptibilities of a driven channel.
    And in both cases the device can remain unitary once the realized field is specified. Thanks for reading!
  </p>

</section>


      <!-- Second ad block (NO second AdSense script include) -->
      <ins class="adsbygoogle"
           style="display:block; text-align:center;"
           data-ad-layout="in-article"
           data-ad-format="fluid"
           data-ad-client="ca-pub-6719988103594554"
           data-ad-slot="2406334732"></ins>
      <script>
        (adsbygoogle = window.adsbygoogle || []).push({});
      </script>

      <p><a href="../blog.html">← Back to Blog</a></p>

    </main>
  </div>

  <script>
    async function loadSidebar() {
      const sidebarContainer = document.getElementById('sidebar');
      const response = await fetch('../partials/sidebar.html');
      const html = await response.text();
      sidebarContainer.innerHTML = html;

      const currentPath = window.location.pathname.split('/').pop();
      const links = sidebarContainer.querySelectorAll('a');
      links.forEach(link => {
        if (link.getAttribute('href') === currentPath) {
          link.classList.add('active');
        }
      });

      // Re-render KaTeX in case the injected sidebar contains math
      if (typeof renderMathInElement === "function") {
        renderMathInElement(document.querySelector("main.content"), {
          delimiters: [
            { left: "$$", right: "$$", display: true },
            { left: "\\[", right: "\\]", display: true },
            { left: "$", right: "$", display: false },
            { left: "\\(", right: "\\)", display: false }
          ],
          throwOnError: false,
          macros: { "\\mathbbm": "\\mathbb" },
          ignoredTags: ["script", "noscript", "style", "textarea", "pre", "code"]
        });
      }
    }
    loadSidebar();
  </script>
</body>
</html>
